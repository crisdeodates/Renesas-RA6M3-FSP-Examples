/***********************************************************************************************************************
 * File Name    : hal_entry.c
 * Description  : Contains data structures and functions used in hal_entry.c.
 **********************************************************************************************************************/
/***********************************************************************************************************************
* Copyright (c) 2020 - 2024 Renesas Electronics Corporation and/or its affiliates
*
* SPDX-License-Identifier: BSD-3-Clause
***********************************************************************************************************************/
#include "common_utils.h"
#include "raw_data.h"
#include "jpeg_codec_ep.h"

/*******************************************************************************************************************//**
 * @addtogroup jpeg_codec_ep
 * @{
 **********************************************************************************************************************/

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER


/* Flags to indicate completion of encode/decode operation */
static uint8_t g_encode_complete = false;
static uint8_t g_decode_complete = false;
/* Variable to store image size in callback */
static uint32_t g_encoded_image_size= RESET_VALUE;
/* Variable to store the status of JPEG Driver */
static jpeg_status_t g_jpeg_status = JPEG_STATUS_NONE;
/* Variable for timeout operation monitoring */
uint32_t g_timeout =  UINT32_MAX;

/*Buffers to store input and output data for codec process*/
static uint8_t g_encode_destination_buffer [ENCODE_BUFFER_SIZE] BSP_ALIGN_VARIABLE(8);
static uint32_t g_codec_buffer [IMAGE_SIZE] BSP_ALIGN_VARIABLE(8);


/* 5-bit to 8-bit LUT used in rgb conversion process */
const uint8_t lut_32[] =
{
 0,   8,   16,  25,  33,  41,  49,  58,
 66,  74,  82,  90,  99,  107, 115, 123,
 132, 140, 148, 156, 165, 173, 181, 189,
 197, 206, 214, 222, 230, 239, 247, 255
};

/* 6-bit to 8-bit LUT used in rgb conversion process  */
const uint8_t lut_64[] =
{
 0,   4,   8,   12,  16,  20,  24,  28,
 32,  36,  40,  45,  49,  53,  57,  61,
 65,  69,  73,  77,  81,  85,  89,  93,
 97,  101, 105, 109, 113, 117, 121, 125,
 130, 134, 138, 142, 146, 150, 154, 158,
 162, 166, 170, 174, 178, 182, 186, 190,
 194, 198, 202, 206, 210, 215, 219, 223,
 227, 231, 235, 239, 243, 247, 251, 255
};

/* User defined enum to select format in ycbcr format conversion*/
typedef enum e_pixel_format
{
    PIXEL_FORMAT_ARGB8888,
    PIXEL_FORMAT_RGB565
} pixel_format_t;

/* User defined functions */
static void bitmap_rgb2ycbcr(uint32_t * out, uint8_t * in, uint32_t len, pixel_format_t format);
static void timeout_eror_check(uint32_t timeout_val);
static void jpeg_cleanup(void);

/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    fsp_err_t          err        = FSP_SUCCESS;
    fsp_pack_version_t version    = {RESET_VALUE};

    /* version get API for FLEX pack information */
    R_FSP_VersionGet(&version);

    /* Project information printed on the Console */
    APP_PRINT(BANNER_INFO, EP_VERSION, version.version_id_b.major, version.version_id_b.minor, version.version_id_b.patch);
    APP_PRINT(EP_INFO);

    /* Initialize JPEG Codec Driver */
    err = R_JPEG_Open(&g_jpeg_ctrl, &g_jpeg_cfg);
    /* Handle error */
    if(FSP_SUCCESS != err)
    {
        /* JPEG Codec initialization failed  */
        APP_ERR_PRINT("\r\n ** JPEG Codec driver initialization FAILED ** \r\n");
        APP_ERR_TRAP(err);
    }

    /* Set output buffer for encoding process */
    err = R_JPEG_OutputBufferSet(&g_jpeg_ctrl, g_encode_destination_buffer, sizeof(g_encode_destination_buffer));
    /* Handle error */
    if(FSP_SUCCESS != err)
    {
        jpeg_cleanup();
        APP_ERR_PRINT("\r\n ** R_JPEG_OutputBufferSet FAILED ** \r\n");
        APP_ERR_TRAP(err);
    }

    /* Set Image size parameters */
    jpeg_encode_image_size_t image_params;
    image_params.horizontal_resolution = X_RESOLUTION;
    image_params.vertical_resolution = Y_RESOLUTION;
    image_params.horizontal_stride_pixels = HOR_STRIDE;

    err = R_JPEG_EncodeImageSizeSet(&g_jpeg_ctrl, &image_params);
    /* Handle error */
    if(FSP_SUCCESS != err)
    {
        jpeg_cleanup();
        APP_ERR_PRINT("\r\n ** R_JPEG_EncodeImageSizeSet API FAILED ** \r\n");
        APP_ERR_TRAP(err);
    }

    /* Set Input buffer for encoding process */
    uint8_t * p_chunk = (uint8_t *)image_rgb565;
    g_jpeg_status = JPEG_STATUS_INPUT_PAUSE;
    uint32_t lines = RESET_VALUE;


    while (g_timeout)
    {
        /* Convert rgb image to format that can be encoded by the driver */
        bitmap_rgb2ycbcr (g_codec_buffer, (uint8_t *)(p_chunk + (image_params.horizontal_resolution * lines * 2)),
                          (uint32_t)(image_params.horizontal_resolution * LINES * YCBCR_BYTES_PER_PIXEL), PIXEL_FORMAT_RGB565);

        /* Set the input buffer */
        err = R_JPEG_InputBufferSet(&g_jpeg_ctrl, g_codec_buffer, (uint32_t)(image_params.horizontal_resolution * LINES * YCBCR_BYTES_PER_PIXEL));
        if(FSP_SUCCESS != err)
        {
            jpeg_cleanup();
            APP_ERR_PRINT("\r\n ** R_JPEG_InputBufferSet API FAILED ** \r\n");
            APP_ERR_TRAP(err);
        }

        /* This delay is required for streaming input mode to function correctly.*/
        R_BSP_SoftwareDelay(INPUT_MODE_DELAY, BSP_DELAY_UNITS_MILLISECONDS);

        /* Wait here for an event from callback */
        if(JPEG_STATUS_NONE == g_jpeg_status)
        {
            /* Do Nothing. */
        }
        if (g_jpeg_status & JPEG_STATUS_OPERATION_COMPLETE)
        {
            /* Encode complete */
            break;
        }
        if (g_jpeg_status & JPEG_STATUS_INPUT_PAUSE)
        {
            /* Load next block of input data here (if needed) */
            lines = (uint32_t) (lines + LINES);
        }
        g_timeout--;
    }

    /* Check for timeout error */
    timeout_eror_check(g_timeout);

    /*Reset timeout value */
    g_timeout =  UINT32_MAX;

    /*Wait for encode operation to complete */
    while((true != g_encode_complete))
    {
        g_timeout--;
        timeout_eror_check(g_timeout);
    }

    APP_PRINT("\r\nEncoding is successful. \nUse image viewer feature in e2studio to view encoded image.\r\n");
    APP_PRINT("\r\nEncoded image size: %d\r\n",g_encoded_image_size);

    /* Retrieve the status of Codec driver */
    err = R_JPEG_StatusGet(&g_jpeg_ctrl, &g_jpeg_status);
    /* Handle error */
    if(FSP_SUCCESS != err)
    {
        jpeg_cleanup();
        APP_ERR_PRINT("\r\n ** R_JPEG_StatusGet API FAILED ** \r\n");
        APP_ERR_TRAP(err);
    }


    /* Toggle the mode from Encode to Decode */
    err  = R_JPEG_ModeSet(&g_jpeg_ctrl, JPEG_MODE_DECODE);
    /* Handle error */
    if(FSP_SUCCESS != err)
    {
        jpeg_cleanup();
        APP_ERR_PRINT("\r\n ** R_JPEG_ModeSet API FAILED ** \r\n");
        APP_ERR_TRAP(err);
    }


    /* Set horizontal stride for decoding process */
    err = R_JPEG_DecodeHorizontalStrideSet(&g_jpeg_ctrl, HOR_STRIDE);
    /* Handle error */
    if(FSP_SUCCESS != err)
    {
        jpeg_cleanup();
        APP_ERR_PRINT("\r\n ** R_JPEG_DecodeHorizontalStrideSet API FAILED ** \r\n");
        APP_ERR_TRAP(err);
    }

    /* Reset output buffer for storing decoded data */
    memset(g_codec_buffer, 0x00,sizeof(g_codec_buffer));

    /* Set output buffer for decoding process */
    err = R_JPEG_OutputBufferSet(&g_jpeg_ctrl, g_codec_buffer, IMAGE_SIZE);
    /* Handle error */
    if(FSP_SUCCESS != err)
    {
        jpeg_cleanup();
        APP_ERR_PRINT("\r\n ** R_JPEG_OutputBufferSet API FAILED ** \r\n");
        APP_ERR_TRAP(err);
    }

    /* Set input buffer for decoding process. Entire encoded image is passed for decoding process. */
    err = R_JPEG_InputBufferSet(&g_jpeg_ctrl, g_encode_destination_buffer, sizeof(g_encode_destination_buffer));
    /* Handle error */
    if(FSP_SUCCESS != err)
    {
        jpeg_cleanup();
        APP_ERR_PRINT("\r\n ** R_JPEG_InputBufferSet API FAILED ** \r\n");
        APP_ERR_TRAP(err);
    }

    /* This delay is required for streaming input mode to function correctly.*/
    R_BSP_SoftwareDelay(INPUT_MODE_DELAY, BSP_DELAY_UNITS_MILLISECONDS);

    /*Reset timeout value */
    g_timeout =  UINT32_MAX;

    /*Wait for decode operation to complete */
    while((true != g_decode_complete))
    {
        g_timeout--;
        timeout_eror_check(g_timeout);
    }

    APP_PRINT("\r\nDecoding is successful.\nUse image viewer feature in e2studio to view decoded image.\r\n");
}

/***********************************************************************************************************************
 * Convert an RGB buffer to Y'CbCr 4:2:2.
 *
 * NOTE: The width (in pixels) of the image to be converted must be divisible by 2.
 *
 * Parameters:
 *   out       Pointer to output buffer
 *   in        Pointer to input buffer
 *   len       Length of input buffer (in pixels)
 *   format    Input buffer format (ARGB8888 or RGB565)
 **********************************************************************************************************************/
static void bitmap_rgb2ycbcr (uint32_t * out, uint8_t * in, uint32_t len, pixel_format_t format)
{
    uint16_t in0;
    uint16_t in1;
    uint32_t r0;
    uint32_t g0;
    uint32_t b0;
    uint32_t r1;
    uint32_t g1;
    uint32_t b1;
    uint8_t y0;
    uint8_t y1;
    uint8_t cb0;
    uint8_t cr0;
    uint8_t cb1;
    uint8_t cr1;
    /* Divide length by 2 as we're working with two pixels at a time */
    len >>= SHIFT_BY_1;
    /* Perform the conversion */
    while (len)
    {
        /* Get R, G and B channel values */
        if (format == PIXEL_FORMAT_RGB565)
        {
            /* Get next two 16-bit values */
            in0 = *((uint16_t *) in);
            in += SHIFT_BY_2;
            in1 = *((uint16_t *) in);
            in += SHIFT_BY_2;
            /* Decompose into individual channels */
            r0 = in0 >> 11;
            g0 = (in0 & RGB565_G_MASK) >> 5;
            b0 = in0 & RGB565_B_MASK;
            r1 = in1 >> 11;
            g1 = (in1 & RGB565_G_MASK) >> 5;
            b1 = in1 & RGB565_B_MASK;
        }
        else
        {
            /* Get each ARGB8888 channel in sequence, skipping alpha */
            b0 = *in++;
            g0 = *in++;
            r0 = *in++;
            in++;
            b1 = *in++;
            g1 = *in++;
            r1 = *in++;
            in++;
        }
        /* Convert RGB565 data to RGB888 */
        if (PIXEL_FORMAT_RGB565 == format)
        {
            r0 = lut_32[r0];
            g0 = lut_64[g0];
            b0 = lut_32[b0];
            r1 = lut_32[r1];
            g1 = lut_64[g1];
            b1 = lut_32[b1];
        }
        /* Calculate Y'CbCr 4:4:4 values for the two pixels */
        /* Algorithm based on method shown here: https://sistenix.com/rgb2ycbcr.html */
        /* Original coefficients from https://en.wikipedia.org/wiki/YCbCr#JPEG_conversion */
        y0 = (uint8_t) (((r0 << SHIFT_BY_6) + (r0 << SHIFT_BY_3) + (r0 << SHIFT_BY_2) + r0 +
                (g0 << SHIFT_BY_7) + (g0 << SHIFT_BY_4) + (g0 << SHIFT_BY_2) + (g0 << SHIFT_BY_1) +
                (b0 << SHIFT_BY_4) + (b0 << SHIFT_BY_3) + (b0 << SHIFT_BY_2) + b0
        ) >> 8);
        cb0 = (uint8_t) (C_0 - (((r0 << SHIFT_BY_5) + (r0 << SHIFT_BY_3) + (r0 << 1) + r0 +
                (g0 << SHIFT_BY_6) + (g0 << SHIFT_BY_4) + (g0 << SHIFT_BY_2) + g0 -
                (b0 << SHIFT_BY_7)
        ) >> 8));
        cr0 = (uint8_t) (C_0 + (((r0 << SHIFT_BY_7) -
                (g0 << SHIFT_BY_6) - (g0 << SHIFT_BY_5) - (g0 << SHIFT_BY_3) - (g0 << SHIFT_BY_1) - g0 -
                (b0 << SHIFT_BY_4) - (b0 << SHIFT_BY_2) - b0
        ) >> 8));
        y1 = (uint8_t) (((r1 << SHIFT_BY_6) + (r1 << SHIFT_BY_3) + (r1 << SHIFT_BY_2) + r1 +
                (g1 << SHIFT_BY_7) + (g1 << SHIFT_BY_4) + (g1 << SHIFT_BY_2) + (g1 << SHIFT_BY_1) +
                (b1 << SHIFT_BY_4) + (b1 << SHIFT_BY_3) + (b1 << SHIFT_BY_2) + b1
        ) >> 8);
        cb1 = (uint8_t) (C_0 - (((r1 << SHIFT_BY_5) + (r1 << SHIFT_BY_3) + (r1 << SHIFT_BY_1) + r1 +
                (g1 << SHIFT_BY_6) + (g1 << SHIFT_BY_4) + (g1 << SHIFT_BY_2) + g1 -
                (b1 << SHIFT_BY_7)
        ) >> 8));
        cr1 = (uint8_t) (C_0 + (((r1 << SHIFT_BY_7) -
                (g1 << SHIFT_BY_6) - (g1 << 5) - (g1 << SHIFT_BY_3) - (g1 << SHIFT_BY_1) - g1 -
                (b1 << SHIFT_BY_4) - (b1 << SHIFT_BY_2) - b1
        ) >> 8));
        /* The above code is based on the floating point method shown here: */
        // y0  = (uint8_t) ((0.299F * (float) r0) + (0.587F * (float) g0) + (0.114F * (float) b0));
        // y1  = (uint8_t) ((0.299F * (float) r1) + (0.587F * (float) g1) + (0.114F * (float) b1));
        // cb0 = (uint8_t) (128.0F - (0.168736F * (float) r0) - (0.331264F * (float) g0) + (0.5F * (float) b0));
        // cb1 = (uint8_t) (128.0F - (0.168736F * (float) r1) - (0.331264F * (float) g1) + (0.5F * (float) b1));
        // cr0 = (uint8_t) (128.0F + (0.5F * (float) r0) - (0.418688F * (float) g0) - (0.081312F * (float) b0));
        // cr1 = (uint8_t) (128.0F + (0.5F * (float) r1) - (0.418688F * (float) g1) - (0.081312F * (float) b1));
        /* NOTE: The JPEG Codec expects signed instead of unsigned chrominance values. */
        /* Convert chrominance to -127..127 instead of 1..255 */
        cb0 = (uint8_t) ((int8_t) ((cb0 + cb1 + SHIFT_BY_1) >> SHIFT_BY_1) - C_0);
        cr0 = (uint8_t) ((int8_t) ((cr0 + cr1 + SHIFT_BY_1) >> SHIFT_BY_1) - C_0);
        /* Convert the two 4:4:4 values into 4:2:2 by averaging the chroma, then write to output */
        *out++ = (uint32_t) (y0 + (cb0 << SHIFT_BY_8) + (y1 << 16) + (cr0 << 24));
        len--;
    }
}

/*******************************************************************************************************************//**
 * @brief This function checks for timeout error ends application in an Error Trap.
 * @param[IN]   None
 * @retval      None
 **********************************************************************************************************************/
static void timeout_eror_check(uint32_t timeout_val)
{
    fsp_err_t err = FSP_SUCCESS;

    if (RESET_VALUE >= timeout_val)
    {
        err = FSP_ERR_TIMEOUT;
        APP_ERR_PRINT("\r\n Timeout error\r\n");
        jpeg_cleanup();
        APP_ERR_TRAP(err);
    }
}

/*******************************************************************************************************************//**
 * @brief This function closes opened JPEG Codec module before the project ends up in an Error Trap.
 * @param[IN]   None
 * @retval      None
 **********************************************************************************************************************/
static void jpeg_cleanup(void)
{
    fsp_err_t err = FSP_SUCCESS;

    /* Close JPEG Coded module */
    err = R_JPEG_Close(&g_jpeg_ctrl);
    /* handle error */
    if (FSP_SUCCESS != err)
    {
        /* SPI Close failure message */
        APP_ERR_PRINT("** R_JPEG_Close API for master failed **  \r\n");
    }
}

/*******************************************************************************************************************//**
 * @brief Encode callback function.
 * @param[in]  p_args
 * @retval     None
 **********************************************************************************************************************/
void encode_callback(jpeg_callback_args_t * p_args)
{
    if (NULL != p_args)
    {
        g_jpeg_status = p_args->status;
        /* Retrieve status and set complete flag */
        if ((JPEG_STATUS_IDLE | JPEG_STATUS_OPERATION_COMPLETE) == p_args->status)
        {
            g_encode_complete = true;
        }

        g_encoded_image_size = p_args->image_size;
    }
}

/*******************************************************************************************************************//**
 * @brief Decode callback function.
 * @param[in]  p_args
 * @retval     None
 **********************************************************************************************************************/
void decode_callback(jpeg_callback_args_t * p_args)
{
    if (NULL != p_args)
    {
        g_jpeg_status = p_args->status;
        /* Retrieve status and set complete flag */
        if ((JPEG_STATUS_IDLE | JPEG_STATUS_OPERATION_COMPLETE) == p_args->status)
        {
            g_decode_complete = true;
        }
    }
}



/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event) {
    if (BSP_WARM_START_RESET == event) {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event) {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open(&g_ioport_ctrl, &g_bsp_pin_cfg);
    }
}
