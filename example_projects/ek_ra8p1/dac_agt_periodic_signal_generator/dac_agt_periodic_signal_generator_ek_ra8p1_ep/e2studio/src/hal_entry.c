/***********************************************************************************************************************
 * File Name    : hal_entry.c
 * Description  : Contains data structures and functions used in hal_entry.c
 **********************************************************************************************************************/
/***********************************************************************************************************************
* Copyright (c) 2020 - 2025 Renesas Electronics Corporation and/or its affiliates
*
* SPDX-License-Identifier: BSD-3-Clause
***********************************************************************************************************************/

#include "common_utils.h"
#include "periodic_signal_generator_ep.h"

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER

#define _USE_MATH_DEFINES
#include <math.h>

/* Array to store sine look up table */
static uint16_t look_up_table[SPP_MAX_VAL] = {0};

/* Variable to store the user input for resolution, in samples per period
 * uint16_t to match g_transfer0_cfg.p_info->length */
static volatile uint16_t input_spp;

/* Variable to store the user input for frequency, in Hz */
static volatile uint32_t input_freq;

/* Variable to store the DAC sample frequency */
static volatile double sample_freq;

/* Variable to store maximum input frequency */
static volatile uint32_t freq_max_val;

/* Variable to store minimum input frequency */
static volatile uint32_t freq_min_val;

/* Variable to store AGT clock frequency */
static volatile uint32_t timer_freq_hz;

/* Variable to store the DAC's maximum sample rate in Hz (board-specific) */
static double dac_max_samp_rate;

/* Function to calculate LUT values */
static void generate_lut(void);

/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used. This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    fsp_err_t err = FSP_SUCCESS;
    fsp_pack_version_t version = {RESET_VALUE};

    /* Get FSP version information using the version API */
    R_FSP_VersionGet(&version);

    /* Example project information printed on the Console */
    APP_PRINT(BANNER_INFO, EP_VERSION, version.version_id_b.major, version.version_id_b.minor,\
              version.version_id_b.patch);
    APP_PRINT(EP_INFO);

    /* Accounting for the 'Pin Configuration' limitation in the FSP Users' Manual for r_dac */
#ifdef BOARD_RA2A1_EK
    R_IOPORT_PinCfg(g_ioport.p_ctrl, BSP_IO_PORT_05_PIN_00, ((uint32_t)IOPORT_CFG_ANALOG_ENABLE |\
                    IOPORT_CFG_PERIPHERAL_PIN | IOPORT_PERIPHERAL_CAC_AD));
#endif

    /* Initialize and start the DAC module */
#if (BSP_PERIPHERAL_DAC_B_PRESENT)
    err = R_DAC_B_Open(&g_dac_b0_ctrl, &g_dac_b0_cfg);
    /* Handle error */
    if (FSP_SUCCESS != err)
    { /* DAC_B module open failed */
        APP_ERR_PRINT("\r\n** R_DAC_B_Open API failed **\r\n");
        APP_ERR_TRAP(err);
    }
    err = R_DAC_B_Start(&g_dac_b0_ctrl);
    /* Handle error */
    if (err != FSP_SUCCESS)
    { /* DAC_B start failed */
        APP_ERR_PRINT("\r\n** R_DAC_B_Start API failed **\r\n");
        APP_ERR_TRAP(err);
    }
#else
    err = R_DAC_Open(&g_dac0_ctrl, &g_dac0_cfg);
    /* Handle error */
    if (FSP_SUCCESS != err)
    {   /* DAC module open failed */
        APP_ERR_PRINT("\r\n** R_DAC_Open API failed **\r\n");
        APP_ERR_TRAP(err);
    }
    err = R_DAC_Start(&g_dac0_ctrl);
    /* Handle error */
    if(err != FSP_SUCCESS)
    {   /* DAC start failed */
        APP_ERR_PRINT("\r\n** R_DAC_Start API failed **\r\n");
        APP_ERR_TRAP(err);
    }
#endif /* BSP_PERIPHERAL_DAC_B_PRESENT */

    /* Initialize the DTC, AGT modules */
    err = R_DTC_Open(&g_transfer0_ctrl, &g_transfer0_cfg);
    /* Handle error */
    if (FSP_SUCCESS != err)
    {   /* DTC module open failed */
        APP_ERR_PRINT("\r\n** R_DTC_Open API failed **\r\n");
        APP_ERR_TRAP(err);
    }

    err = R_AGT_Open(&g_timer0_ctrl, &g_timer0_cfg);
    /* Handle error */
    if (FSP_SUCCESS != err)
    {   /* AGT module open failed */
        APP_ERR_PRINT("\r\n** R_AGT_Open API failed **\r\n");
        APP_ERR_TRAP(err);
    }
    err = R_AGT_Start(&g_timer0_ctrl);
    if (FSP_SUCCESS != err)
    {  /* AGT start failed */
       APP_ERR_PRINT("\r\n** R_AGT_Start API failed **\r\n");
       APP_ERR_TRAP(err);
    }

    /* Calculate the DAC's maximum sample rate in Hz. This is calculated by the formula: 1/DAC_MAX_CONVERSION_PERIOD
     * DAC_MAX_CONVERSION_PERIOD for each MCU is specified in the Electrical Characteristics
     * section of the RA User's Manual */
    dac_max_samp_rate = 1 / (DAC_MAX_CONVERSION_PERIOD * pow(10, -6));

    while(1)
    {
        /* Prompt the user to input the desired number of samples per period and validate the input range */
        APP_PRINT("\r\nEnter the desired number of samples per period for the output sine wave."\
                  " Valid range: %d to %d\r\n", SPP_MIN_VAL, SPP_MAX_VAL);

        uint8_t is_not_valid = 1;

        while(is_not_valid)
        {
            if(APP_CHECK_DATA)
            {
                uint8_t readBuff[BUFFER_SIZE_DOWN] = { RESET_VALUE };
                APP_READ(readBuff);
                input_spp = (uint16_t) atoi ((char*) readBuff);

                if((input_spp >= SPP_MIN_VAL) && (input_spp <= SPP_MAX_VAL))
                {
                   is_not_valid = 0;
                }
                else
                {
                   APP_PRINT("\r\nValue out of bounds. Please enter desired samples per period within"\
                             " the range: %d to %d\r\n", SPP_MIN_VAL, SPP_MAX_VAL);
                }
            }
        }
        APP_PRINT("%d samples per period selected\r\n", input_spp);

        /* Calculate the maximum possible frequency, determined by the relation:
         * dac_max_samp_rate = freq_max_val * input_spp */
        freq_max_val = (uint32_t)(dac_max_samp_rate / input_spp);

        /* Get the AGT clock frequency */
        timer_freq_hz = R_FSP_SystemClockHzGet(FSP_PRIV_CLOCK_PCLKB) >> g_timer0_cfg.source_div;

        /* Calculate the minimum value allowed output frequency, based on:
         *   - AGT timer resolution (16-bit: AGT_MAX_PERIOD_16BIT or 32-bit: AGT_MAX_PERIOD_32BIT)
         *   - Number of samples per waveform cycle (input_spp)
         *   - Clock frequency supplied to AGT (timer_freq_hz)
         *
         * For 16-bit AGT: freq_min_val = (timer_freq_hz / (input_spp * AGT_MAX_PERIOD_16BIT)) + 1U
         * For 32-bit AGT: freq_min_val = (timer_freq_hz / (input_spp * AGT_MAX_PERIOD_32BIT)) + 1U
         */
#if (BSP_PERIPHERAL_AGTW_PRESENT)
        freq_min_val = (timer_freq_hz / (input_spp * AGT_MAX_PERIOD_32BIT)) + 1U;
#else
        freq_min_val = (timer_freq_hz / (input_spp * AGT_MAX_PERIOD_16BIT)) + 1U;
#endif /* BSP_PERIPHERAL_AGTW_PRESENT */

        /* Prompt the user to enter the desired output frequency and validate it against the allowed range */
        APP_PRINT("\r\nEnter desired frequency for output sine wave, in Hz."\
                  " Valid range: %d to %d Hz\r\n", freq_min_val, freq_max_val);
        is_not_valid = 1;

        while(is_not_valid)
        {
            if(APP_CHECK_DATA)
            {
                uint8_t readBuff[BUFFER_SIZE_DOWN] = { RESET_VALUE };
                APP_READ(readBuff);
                input_freq = (uint32_t) atoi ((char*) readBuff);

                if((input_freq >= freq_min_val) && (input_freq <= freq_max_val))
                {
                    is_not_valid = 0;
                }
                else
                {
                    APP_PRINT("\r\nValue out of bounds. Please enter desired frequency within"\
                              " the range: %d to %d Hz\r\n", freq_min_val, freq_max_val);
                }
            }
        }
        APP_PRINT("%d Hz selected\r\n", input_freq);

        /* Calculate the look up table */
        generate_lut();

        /* Reconfigure the DTC:
         * Destination: Address of DADRn register
         * Source: Base address of the look up table
         * Length: Length of the look up table */
#if defined (BOARD_RA8T1_MCK)
        g_transfer0_cfg.p_info->p_dest = (void *) DADR1;
#else
        g_transfer0_cfg.p_info->p_dest = (void *) DADR0;
#endif /* BOARD_RA8T1_MCK */
        g_transfer0_cfg.p_info->p_src = &look_up_table;
        g_transfer0_cfg.p_info->length = input_spp;

        err = R_DTC_Reconfigure(&g_transfer0_ctrl, g_transfer0_cfg.p_info);
        /* Handle error */
        if (FSP_SUCCESS != err)
        {   /* DTC module enable failed */
           APP_ERR_PRINT("\r\n** R_DTC_Reconfigure API failed **\r\n");
           APP_ERR_TRAP(err);
        }

        /* Calculate the output sample frequency of the DAC for the specified wave */
        sample_freq = input_spp * input_freq;

        /* Calculate and set the AGT counts per period, based on the relation between output sample frequency
         * and the AGT clock source frequency */
        volatile uint32_t period_counts = (uint32_t) (timer_freq_hz / sample_freq);

        err = R_AGT_PeriodSet(&g_timer0_ctrl, period_counts);
        if (FSP_SUCCESS != err)
        {
           /* AGT period set failed */
           APP_ERR_PRINT("\r\n** R_AGT_PeriodSet API failed **\r\n");
           APP_ERR_TRAP(err);
        }

        /* Provide feedback to J-Link RTT to indicate that the wave is being generated */
        APP_PRINT("\r\nOutputting %d Hz wave with %d samples per period\r\n", input_freq, input_spp);

    }
#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

void generate_lut(void)
{
    /* Calculate look up table */
    for(int i = 0; i < input_spp; ++i)
    {
        look_up_table[i] = (uint16_t) (DAC_MID_VAL*(cos(2*M_PI*i/input_spp) + 1));
        /* Check LUT values if requested by the user */
        /* APP_PRINT("\r\n  %d", look_up_table[i]); */
    }
}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process. This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take
         * more than 6us */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup */

        /* Configure pins */
        R_IOPORT_Open (&IOPORT_CFG_CTRL, &IOPORT_CFG_NAME);

#if BSP_CFG_SDRAM_ENABLED

        /* Setup SDRAM and initialize it. Must configure pins first */
        R_BSP_SdramInit(true);
#endif
    }
}

#if BSP_TZ_SECURE_BUILD

FSP_CPP_HEADER
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build
 * (Remove this if it is not required to build) */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
FSP_CPP_FOOTER

#endif
