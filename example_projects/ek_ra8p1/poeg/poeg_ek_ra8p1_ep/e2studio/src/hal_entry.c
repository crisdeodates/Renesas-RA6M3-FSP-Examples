/***********************************************************************************************************************
 * File Name    : hal_entry.c
 * Description  : Contains functions
 **********************************************************************************************************************/
/***********************************************************************************************************************
* Copyright (c) 2022 - 2025 Renesas Electronics Corporation and/or its affiliates
*
* SPDX-License-Identifier: BSD-3-Clause
***********************************************************************************************************************/

#include "poeg_ep.h"

/*******************************************************************************************************************//**
 * @addtogroup poeg_ep
 * @{
 **********************************************************************************************************************/

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER

/* Global variables */
uint8_t g_num_bytes = RESET_VALUE;
uint16_t g_dac_val = RESET_VALUE;
extern bsp_leds_t g_bsp_leds;
#if (BSP_PERIPHERAL_ACMPHS_PRESENT)
comparator_info_t g_stabilize_time = {RESET_VALUE};
static volatile bool b_comparator_state_flag = false;
#endif /* BSP_PERIPHERAL_ACMPHS_PRESENT */
static volatile uint8_t g_interrupt_pin_trigger_flag = RESET_VALUE;
static volatile uint8_t g_interrupt_output_level_flag = RESET_VALUE;
static volatile uint8_t g_interrupt_acmphs_flag = RESET_VALUE;
static volatile uint8_t g_mode_flag = RESET_VALUE;

/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used. This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    fsp_err_t err = FSP_SUCCESS;
    fsp_pack_version_t version = {RESET_VALUE};
    /* Version get API for FLEX pack information */
    R_FSP_VersionGet(&version);

    /* Example Project information printed on the Console */
    APP_PRINT(BANNER_INFO, EP_VERSION, version.version_id_b.major, version.version_id_b.minor, \
              version.version_id_b.patch);
    APP_PRINT(EP_INFO);

    /* Turn OFF LED1 */
    R_IOPORT_PinWrite(&g_ioport_ctrl, g_bsp_leds.p_leds[STATE_LED], LED_OFF);

    /* Initialize the POEG0 */
    err = init_poeg0_module();
    /* Handle error */
    if(FSP_SUCCESS != err)
    {
        APP_ERR_PRINT("\r\nPOEG0 initialization failed\r\n");
        APP_ERR_TRAP(err);
    }
    else
    {
        APP_PRINT("\r\nPOEG0 initialized successfully\r\n");
    }

    /* Initialize the POEG1 */
    err = init_poeg1_module();
    /* Handle error */
    if(FSP_SUCCESS != err)
    {
        APP_ERR_PRINT("\r\nPOEG1 initialization failed\r\n");
        /* De-initialize the POEG0 */
        deinit_poeg0_module();
        APP_ERR_TRAP(err);
    }
    else
    {
        APP_PRINT("\r\nPOEG1 initialized successfully\r\n");
    }

    /* Initialize the Timer1 in PWM mode */
    err = init_gpt_timer_pwm1();
    /* Handle error */
    if(FSP_SUCCESS != err)
    {
        APP_ERR_PRINT("\r\nGPT1 timer initialization failed\r\n");
        /* De-initialize the POEG0, POEG1 */
        deinit_poeg_module();
        APP_ERR_TRAP(err);
    }
    else
    {
        APP_PRINT("GPT1 initialized successfully\r\n");
    }

    /* Initialize the Timer2 in PWM mode */
    err = init_gpt_timer_pwm2();
    /* Handle error */
    if(FSP_SUCCESS != err)
    {
        APP_ERR_PRINT("\r\nGPT2 timer initialization failed\r\n");
        /* De-initialize the POEG0, POEG1 */
        deinit_poeg_module();
        /* De-initialize the GPT timer1 */
        deinit_gpt_timer(&g_timer_pwm1_ctrl);
        APP_ERR_TRAP(err);
    }
    else
    {
        APP_PRINT("GPT2 initialized successfully\r\n");
    }

#if (BSP_PERIPHERAL_ACMPHS_PRESENT)
    /* Initialize the ACMPHS */
    err = enable_acmphs_mode_modules();
    /* Handle error */
    if (FSP_SUCCESS != err)
    {
        APP_ERR_PRINT("\r\nACMPHS initialization failed\r\n");
        /* De-initialize the POEG0, POEG1 */
        deinit_poeg_module();
        /* De-initialize the GPT timer1, GPT timer2 */
        deinit_gpt_timer(&g_timer_pwm1_ctrl);
        deinit_gpt_timer(&g_timer_pwm2_ctrl);
        APP_ERR_TRAP(err);
    }
    else
    {
        APP_PRINT("ACMPHS initialized successfully\r\n");
    }
#endif /* BSP_PERIPHERAL_ACMPHS_PRESENT */

    while(true)
    {
        APP_PRINT(MENU_TITLE);
        APP_PRINT(EP_MENU);
        APP_PRINT(OPTION_1_INFO);
#if (BSP_PERIPHERAL_ACMPHS_PRESENT)
        APP_PRINT(OPTION_4_INFO);
#endif /* BSP_PERIPHERAL_ACMPHS_PRESENT */

        /* Process input only when the user has provided one */
        while(!APP_CHECK_DATA);
        if (APP_CHECK_DATA)
        {
            poeg_ouput_disable_and_reset_options();
        }
    }

#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

/*******************************************************************************************************************//**
 * @brief       This function reads the command(input) for RTT and processes the command for POEG output disable.
 * @param[in]   None
 * @retval      FSP_SUCCESS                  Upon successful
 * @retval      Any Other Error code apart from FSP_SUCCESS  Upon Unsuccessful
 **********************************************************************************************************************/
fsp_err_t poeg_ouput_disable_and_reset_options(void)
{
    fsp_err_t err = FSP_SUCCESS;

    /* Variable to store the user input */
    uint8_t rByte[BUFFER_SIZE_DOWN] = {NULL_CHAR};
    uint8_t converted_rtt_input = RESET_VALUE;
#if defined (BOARD_RA8E1_FPB) || defined (BOARD_RA8E2_EK)
    uint8_t volt_str[5] = {RESET_VALUE};
    float dac_volt      = {RESET_VALUE};
#endif

    APP_READ(rByte);
    /* User input selection */
    converted_rtt_input = (uint8_t)atoi((char *)rByte);

    switch (converted_rtt_input)
    {
        /* POEG_TRIGGER_ON_GTETRG_INPUT_PIN_LEVEL - Disables GPT output pins based
         * on GTETRG input pin level */
        case POEG_TRIGGER_ON_GTETRG_INPUT_PIN_LEVEL:
        {
            /* Start PWM Timer */
            err = R_GPT_Start(&g_timer_pwm2_ctrl);
            /* Handle error */
            if (FSP_SUCCESS != err)
            {
                APP_ERR_PRINT("\r\nR_GPT_Start API failed\r\n");
                return(err);
            }
            else
            {
                APP_PRINT("Started Timer2 in PWM Mode\r\n");
            }
            APP_PRINT("Enter any key to Disable GPT output using GTETRG trigger pin mode\r\n");
            while(true)
            {
                if (APP_CHECK_DATA)
                {
                    APP_READ(rByte);
                    break;
                }
            }
            g_mode_flag = POEG_TRIGGER_ON_GTETRG_INPUT_PIN_LEVEL;
            /* Enable IRQ */
            NVIC_EnableIRQ(VECTOR_NUMBER_POEG1_EVENT);
            APP_PRINT("\r\nGive active LOW signal at "GTETRG_PIN"\r\n");
            while(!g_interrupt_pin_trigger_flag)
            {
                /* Waiting for interrupt flag */
            }
            APP_PRINT("\r\nPOEG trigger on GTETRG input pin level successful\r\n");
            break;
        }

        /* POEG_OUTPUT_DISABLE_USING_SOFTWARE_API - Disables GPT output pins by software API */
        case POEG_OUTPUT_DISABLE_USING_SOFTWARE_API:
        {
            /* Start PWM Timer */
            err = R_GPT_Start(&g_timer_pwm2_ctrl);
            /* Handle error */
            if (FSP_SUCCESS != err)
            {
                APP_ERR_PRINT("\r\nR_GPT_Start API failed\r\n");
                return(err);
            }
            else
            {
                APP_PRINT("\r\nStarted Timer2 in PWM Mode\r\n");
            }
            APP_PRINT("Enter any key to Disable GPT output using API\r\n");
            while(true)
            {
                if (APP_CHECK_DATA)
                {
                    APP_READ(rByte);
                    /* Disable POEG1 GPT output pins using software API */
                    err = R_POEG_OutputDisable(&g_poeg1_ctrl);
                    break;
                }
            }
            /* Handle error */
            if (FSP_SUCCESS != err)
            {
                APP_ERR_PRINT("\r\nPOEG Output disable API failed\r\n");
            }
            APP_PRINT("\r\nPOEG output disable using software API successful\r\n");
            /* Turn ON LED1 */
            R_IOPORT_PinWrite(&g_ioport_ctrl, g_bsp_leds.p_leds[STATE_LED], LED_ON);
            g_mode_flag     =  POEG_OUTPUT_DISABLE_USING_SOFTWARE_API;
            break;
        }

        /* POEG_OUTPUT_DISABLE_ON_GTIOC_OUTPUT_LEVEL - Disables GPT output pins on GTIOC pins level */
        case POEG_OUTPUT_DISABLE_ON_GTIOC_OUTPUT_LEVEL:
        {
            err = R_GPT_Start(&g_timer_pwm1_ctrl);
            /* Handle error */
            if (FSP_SUCCESS != err)
            {
                APP_ERR_PRINT("\r\nR_GPT_Start API failed\r\n");
                return(err);
            }
            else
            {
                APP_PRINT("\r\nStarted Timer1 in PWM Mode\r\n");
            }
            APP_PRINT("\r\nEnter any key to Disable GPT PWM output level\r\n");
            while(true)
            {
                if (APP_CHECK_DATA)
                {
                    APP_READ(rByte);
                    break;
                }
            }
            g_mode_flag     = POEG_OUTPUT_DISABLE_ON_GTIOC_OUTPUT_LEVEL;

            /* Enable GPT output on GTIOCA pin.
             * When the GTIOCxA pin and the GTIOCxB pin are driven to an active level simultaneously,
             * the GPT generates an output-disable request to the POEG. */
            err = R_GPT_OutputEnable(&g_timer_pwm1_ctrl, GPT_IO_PIN_GTIOCA);
            /* Handle error */
            if (FSP_SUCCESS != err)
            {
               APP_ERR_PRINT("\r\nR_GPT_OutputEnable API failed\r\n");
               return(err);
            }
            /* Enable IRQ */
            NVIC_EnableIRQ(VECTOR_NUMBER_POEG0_EVENT);

            while(!g_interrupt_output_level_flag)
            {
                /* Waiting for interrupt flag */
            }
            APP_PRINT("\r\nPOEG output disable on GPT output level successful\r\n");
            break;
        }
#if (BSP_PERIPHERAL_ACMPHS_PRESENT)
        /* POEG_OUTPUT_DISABLE_ON_ACMPHS_EVENTS - Disables GPT output pins based on comparator crossing events */
        case POEG_OUTPUT_DISABLE_ON_ACMPHS_EVENTS:
        {
            APP_PRINT("\r\nPlease refer to Hardware Connections section to connect hardware correctly\r\n");

            err = R_GPT_Start(&g_timer_pwm2_ctrl);
            /* Handle error */
            if (FSP_SUCCESS != err)
            {
                APP_ERR_PRINT("\r\nR_GPT_Start API failed\r\n");
                return(err);
            }
            else
            {
                APP_PRINT("\r\nStarted Timer2 in PWM Mode\r\n");
            }
#if defined (BOARD_RA8E1_FPB) || defined (BOARD_RA8E2_EK)
            APP_PRINT("\r\nInternal reference voltage (Vref) is used as reference voltage source."
                      "\r\nIt is set to 1.18V (Equivalent to a digital value 1465).\r\n");
#endif
            /* Enable IRQ */
            NVIC_EnableIRQ(VECTOR_NUMBER_POEG1_EVENT);
            g_mode_flag     =  POEG_OUTPUT_DISABLE_ON_ACMPHS_EVENTS;
            while(!g_interrupt_acmphs_flag)
            {
                g_num_bytes = RESET_VALUE;
                g_dac_val   = RESET_VALUE;
                /* Reset buffer */
                memset(rByte,NULL_CHAR,sizeof(rByte));

#if defined (BOARD_RA8E1_FPB) || defined (BOARD_RA8E2_EK)
                APP_PRINT("\r\nEnter the DAC0 Value between (0 - 1400) or (1600 - 4095) to compare:");
#else
                APP_PRINT("\r\nEnter the DAC1 Value between (0 - 2000) or (2100 - 4095) to compare:");
#endif
                APP_PRINT("\r\nIf the ADC input voltage exceeds "ADC_REF_VAL", the ACMPHS interrupt will occur;"\
                          "\r\nOtherwise, no action is taken");
                while (RESET_VALUE == g_num_bytes)
                {
                    if (APP_CHECK_DATA)
                    {
                        /* Take the user input */
                        g_num_bytes = (uint8_t)APP_READ(rByte);
                        if (RESET_VALUE == g_num_bytes)
                        {
                            APP_PRINT("\r\nInvalid Input\r\n");
                        }
                    }
                }

                /* Conversion from input string to integer value */
                g_dac_val =  (uint16_t) (atoi((char *)rByte));
                APP_PRINT("\r\nInput DAC value: %d\r\n", g_dac_val);

                /* Check for out of range value */
                if (DAC_MAX_VAL < g_dac_val)
                {
                    APP_ERR_PRINT(" \r\nInvalid input, INPUT value is out of range(0 - 4095)\r\n");
                }
                else if ((LOW_VAL < g_dac_val) &&  (HIGH_VAL > g_dac_val))
                {
                    APP_ERR_PRINT(" \r\nFluctuating voltage range\r\n");
                }
                else
                {
#if defined (BOARD_RA8E1_FPB) || defined (BOARD_RA8E2_EK)
            /* Write to DAC0 channel */
            err = R_DAC_Write(&g_dac0_ctrl, g_dac_val);
            /* Handle error */
            if (FSP_SUCCESS != err)
            {
                APP_ERR_PRINT("\r\nR_DAC_Write API failed for DAC0\r\n");
                deinit_dac_and_acmphs();
                APP_ERR_TRAP(err);
            }

            /* Conversion from digital value to analog value */
            dac_volt = (float)((g_dac_val * V_REF)/(DAC_MAX_VAL+1));
            snprintf((char *)volt_str, sizeof(volt_str), "%0.2f", dac_volt);
            APP_PRINT("\r\nInput voltage source for ACMPHS module: %sV\r\n", volt_str);
#else
            /* Write to DAC1 channel */
#if (BSP_PERIPHERAL_DAC_B_PRESENT)
            err = R_DAC_B_Write(&g_dac1_ctrl, g_dac_val);
#else
            err = R_DAC_Write(&g_dac1_ctrl, g_dac_val);
#endif
            /* Handle error */
            if (FSP_SUCCESS != err)
            {
                APP_ERR_PRINT("\r\nR_"DAC_TYPE"_Write API failed for DAC1\r\n");
                deinit_dac_and_acmphs();
                APP_ERR_TRAP(err);
            }
#endif

                    /* Wait for the minimum stabilization wait time */
                    R_BSP_SoftwareDelay(g_stabilize_time.min_stabilization_wait_us, BSP_DELAY_UNITS_MICROSECONDS);
                    R_BSP_SoftwareDelay(1, BSP_DELAY_UNITS_SECONDS);
                }
            }
            APP_PRINT("\r\nPOEG output disable successful on ACMPHS crossing events ");
            break;
        }
#endif /* BSP_PERIPHERAL_ACMPHS_PRESENT */
        /* POEG_RESET - Resets the POEG status */
        case  POEG_RESET:
        {
            err = reset_poeg_module() ;
            /* Handle error */
            if (FSP_SUCCESS != err)
            {
                APP_ERR_PRINT("\r\nFailed to reset POEG with error code: 0x%x",err);
            }
            break;
        }

        default:
        {
#if (BSP_PERIPHERAL_ACMPHS_PRESENT)
            APP_PRINT("\r\nInvalid input, please enter the value between 1-5\r\n");
#else
            APP_PRINT("\r\nInvalid input, please enter the value between 1-4\r\n");
#endif /* BSP_PERIPHERAL_ACMPHS_PRESENT */
            break;
        }
    }
    return err;
}

/*******************************************************************************************************************//**
 * @brief       This function is used for POEG Channel0 callback to disable the IRQ and set the Mode flags
 * @param[in]   poeg_callback_args_t * p_arg
 * @return      None
 **********************************************************************************************************************/
void channel0_user_callback (poeg_callback_args_t * p_args)
{
    FSP_PARAMETER_NOT_USED(p_args);
    /* Turn ON LED1 */
    R_IOPORT_PinWrite(&g_ioport_ctrl, g_bsp_leds.p_leds[STATE_LED], LED_ON);
    if(POEG_OUTPUT_DISABLE_ON_GTIOC_OUTPUT_LEVEL == g_mode_flag)
    {
        APP_PRINT("\r\nInterrupt occur in GPT OUTPUT LEVEL Mode\r\n");
        g_interrupt_output_level_flag = SET_FLAG;
    }

    /* If the POEG0 cannot be reset, disable the POEG0 interrupt to prevent it from firing continuously */
    NVIC_DisableIRQ(VECTOR_NUMBER_POEG0_EVENT);
}

/*******************************************************************************************************************//**
 * @brief       This function is used for POEG Channel1 callback to disable the IRQ and set the Mode flag
 * @param[in]   poeg_callback_args_t * p_arg
 * @return      None
 **********************************************************************************************************************/
void channel1_user_callback(poeg_callback_args_t * p_args)
{
    FSP_PARAMETER_NOT_USED(p_args);
    /* Turn ON LED1 */
    R_IOPORT_PinWrite(&g_ioport_ctrl, g_bsp_leds.p_leds[STATE_LED], LED_ON);
#if (BSP_PERIPHERAL_ACMPHS_PRESENT)
    if(POEG_OUTPUT_DISABLE_ON_ACMPHS_EVENTS == g_mode_flag)
    {
        APP_PRINT("\r\nInterrupt occur in ACMPHS Mode\r\n");
        g_interrupt_acmphs_flag = SET_FLAG;
    }
#endif /* BSP_PERIPHERAL_ACMPHS_PRESENT */
    if(POEG_TRIGGER_ON_GTETRG_INPUT_PIN_LEVEL == g_mode_flag)
    {
        APP_PRINT("\r\nInterrupt occur in Pin Trigger Mode\r\n");
        g_interrupt_pin_trigger_flag = SET_FLAG;
    }

    /* If the POEG1 cannot be reset, disable the POEG1 interrupt to prevent it from firing continuously */
    NVIC_DisableIRQ(VECTOR_NUMBER_POEG1_EVENT);
}

#if (BSP_PERIPHERAL_ACMPHS_PRESENT)
/*******************************************************************************************************************//**
 * @brief       This function is used for ACMPHS callback
 * @param[in]   comparator_callback_args_t *p_args
 * @return      None
 **********************************************************************************************************************/
void acmphs_user_callback(comparator_callback_args_t *p_args)
{
    /* Check for the channel 0 of comparator */
    if(CHANNEL_ZERO == p_args->channel)
    {
        /* Toggle the flag */
        b_comparator_state_flag = !b_comparator_state_flag;
    }
}
#endif /* BSP_PERIPHERAL_ACMPHS_PRESENT */

/*******************************************************************************************************************//**
 * @brief       This function is used to reset the POEG module
 * @param[in]   None
 * @retval      FSP_SUCCESS                  Upon successful POEG Reset
 * @retval      Any Other Error code apart from FSP_SUCCESS  Upon Unsuccessful
 **********************************************************************************************************************/
fsp_err_t reset_poeg_module(void)
{
    fsp_err_t err = FSP_SUCCESS;

    /* Variable to store user input */
    uint8_t rByte[BUFFER_SIZE_DOWN] = {NULL_CHAR};
    uint8_t converted_rtt_input = RESET_VALUE;

    APP_PRINT(RESET_MENU);
    /* Process input only when the user has provided one */
    while(!APP_CHECK_DATA);
    if (APP_CHECK_DATA)
    {
        APP_READ(rByte);
        converted_rtt_input = (uint8_t)atoi((char *)rByte);
    }
    switch (converted_rtt_input)
    {
        case POEG_CHANNEL_0:
        {
            /* Disable GPT output on GTIOCA pin to prevent continuous triggering of POEG
             * due to sustained output signal */
            err = R_GPT_OutputDisable(&g_timer_pwm1_ctrl, GPT_IO_PIN_GTIOCA);
            /* Handle error */
            if (FSP_SUCCESS != err)
            {
               APP_ERR_PRINT("\r\nR_GPT_OutputDisable API failed\r\n");
               return(err);
            }

            err = R_POEG_Reset(&g_poeg0_ctrl);
            /* Handle error */
            if (FSP_SUCCESS != err)
            {
                APP_ERR_PRINT("\r\n R_POEG_Reset API failed\r\n");
                return(err);
            }
            APP_PRINT("\r\n RESET POEG 0 successful\r\n");
            /* Turn OFF LED1 */
            R_IOPORT_PinWrite(&g_ioport_ctrl, g_bsp_leds.p_leds[STATE_LED], LED_OFF);
            g_interrupt_output_level_flag = CLEAR_FLAG;
            break;
        }

        case POEG_CHANNEL_1:
        {
            err = R_POEG_Reset(&g_poeg1_ctrl);
            /* Handle error */
            if (FSP_SUCCESS != err)
            {
                APP_ERR_PRINT("\r\n R_POEG_Reset API failed\r\n");
                return(err);
            }
            APP_PRINT("\r\n RESET POEG 1 successful\r\n");
            /* Turn OFF LED1 */
            R_IOPORT_PinWrite(&g_ioport_ctrl, g_bsp_leds.p_leds[STATE_LED], LED_OFF);
            g_interrupt_acmphs_flag = CLEAR_FLAG;
            g_interrupt_pin_trigger_flag = CLEAR_FLAG;
            break;
        }

        default:
        {
            APP_PRINT("\r\nInvalid input, please enter the value between 1-2\r\n");
            break;
        }
    }
    return err;
}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process. This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take
         * more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open (&IOPORT_CFG_CTRL, &IOPORT_CFG_NAME);

#if BSP_CFG_SDRAM_ENABLED

        /* Setup SDRAM and initialize it. Must configure pins first. */
        R_BSP_SdramInit(true);
#endif
    }
}

#if BSP_TZ_SECURE_BUILD

FSP_CPP_HEADER
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build
 * (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
FSP_CPP_FOOTER

#endif

/*******************************************************************************************************************//**
 * @} (end addtogroup poeg_ep)
 **********************************************************************************************************************/
